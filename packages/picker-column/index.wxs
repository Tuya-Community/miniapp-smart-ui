/* eslint-disable */
var style = require('../wxs/style.wxs');
var addUnit = require('../wxs/add-unit.wxs');
var wxUtils = require('../wxs/utils.wxs');

var startPo = { y: 0 }; // 记录当前拖动元素的开始的位置

const setStyle = (ownerInstance, style, selector) => {
  const dom = wxUtils.queryComponent(ownerInstance, selector);
  if (!dom) {
    console.log(selector, '--selector 无法获取');
    return
  }
  dom.setStyle(style);
};

function optionText(options, optionIndex, valueKey) {
  var option = options[optionIndex];
  return wxUtils.isObj(option) && option[valueKey] != null ? option[valueKey] : option;
}

function rootStyle(data) {
  return style({
    height: addUnit(data.itemHeight * data.visibleItemCount),
  });
}

var state = {}

var preStateObj = {}

function updateState(instanceId, key, value) {
  if (!key) return;
  state[instanceId] = state[instanceId] || {}
  state[instanceId][key] = value
}

function getCurrState(instanceId) {
  return state[instanceId]
}

function updatePreState(instanceId, state) {
  const preStateStr = JSON.stringify(state)
  preStateObj[instanceId] = preStateStr;
}

function getPreState(instanceId) {
  return preStateObj[instanceId]
}

function wrapperStyle(data) {
  var perAngle = 360 / (data.visibleItemCount * 4 - 2)
  var rotate = perAngle * data.animationIndex;
  var optionsVIndexList = data.optionsVIndexList;
  var cssVar = optionsVIndexList.reduce((previousValue, currentValue, currentIndex) => {
    if (currentValue === '' || currentValue === undefined) return previousValue;
    const text = optionText(data.options, currentValue, data.valueKey);
    if(text === undefined) return previousValue;
    previousValue[`--picker-item-content_${currentIndex}`] = `"${text}"`;
    return previousValue;
  }, {});
  return style({
    'text-indent': data.unit ? '-8rpx' : '0',
    transition: data.moving ? 'none' : 'transform ' + data.animationTime + 'ms cubic-bezier(0.2, 0.9, 0.25, 1)',
    'line-height': addUnit(data.itemHeight),
    transform: `rotateX(${rotate}deg)`,
    ...cssVar
  });
}


function adjustIndex(index, options) {
  const count = options.length;
  index = wxUtils.range(index, 0, count);
  for (let i = index; i < count; i++) {
    if (!isDisabled(options[i])) return i;
  }
  for (let i = index - 1; i >= 0; i--) {
    if (!isDisabled(options[i])) return i;
  }
}

function isDisabled(option) {
  return typeof option === 'object' && option.disabled;
}

function wrapperInterStyle(data) {
  var offset = data.renderStart * data.itemHeight;
  offset = addUnit(offset);
  return style({
    'padding-top': offset,
  });
}

function wrapperItemStyle(data) {
  var heightStyleStr = "height: " + data.itemHeight + 'px;'
  var perAngle = 360 / (data.visibleItemCount * 4 - 2)
  var transformStyleStr = style({
    transform: `rotateX(${360 - data.index * perAngle}deg) translateZ(${data.itemHeight * data.visibleItemCount / 2}px) translateX(-50%) scale(0.88);`, //  scale(0.88)
    top: `calc(50% - ${data.itemHeight / 2}px)`,
  });
  return transformStyleStr + ';' + heightStyleStr
}

function wrapperItemClass(data) {
  const state = getCurrState(data.instanceId);
  const optionsVIndexList = state?.optionsVIndexList || data.optionsVIndexList;
  const animationIndex = state?.animationIndex ?? data.animationIndex;
  const optionIndex = optionsVIndexList[data.index];
  const option = data.options[optionIndex];
  var isActive = typeof optionIndex === 'number' && Math.abs(optionIndex - animationIndex) < 0.5;
  var activeClass = 'active-class';
  return wxUtils.bem('picker-column__item', { disabled: wxUtils.isObj(option) && option.disabled, selected: isActive }) + ' ' + (isActive ? activeClass : '');
}

function wrapperItemTextStyle(data) {
  const state = getCurrState(data.instanceId);
  const optionsVIndexList = state?.optionsVIndexList || data.optionsVIndexList;
  const animationIndex = state?.animationIndex ?? data.animationIndex;
  const optionIndex = optionsVIndexList[data.index];
  var fontStyle = data.fontStyle;
  var activeStyle = data.activeStyle;
  var isActive = typeof optionIndex === 'number' && Math.round(animationIndex) === optionIndex;
  return (fontStyle ? fontStyle.replace(';', '') + ';' : '') + (isActive ? activeStyle.replace(';', '') + ';' : '')
}

function getDomState(ownerInstance) {
  const dom = wxUtils.queryComponent(ownerInstance, '.smart-picker-column');
  const state = dom.getDataset();
  return state
}

function initDomState(instanceId, ownerInstance) {
  const state = getDomState(ownerInstance);
  updateState(instanceId, 'options', state.options)
  updateState(instanceId, 'valueKey', state.valuekey)
  updateState(instanceId, 'itemHeight', state.itemheight)
  updateState(instanceId, 'visibleItemCount', state.visibleitemcount)
  updateState(instanceId, 'activeIndex', state.activeindex)
  updateState(instanceId, 'loop', state.loop)
  updateState(instanceId, 'animationTime', state.animationtime)
}


const updateValue = (instanceId, key) => (newOptions, oldOptions, ownerInstance) => {
  if (!instanceId) return;
  initDomState(instanceId, ownerInstance)
  updateState(instanceId, key, newOptions)
  updateListView(instanceId, ownerInstance)
}

const updateListView = (instanceId, ownerInstance) => {
  const state = getCurrState(instanceId);
  const domState = getDomState(ownerInstance);
  if(getPreState(instanceId) === JSON.stringify(domState) || !state.itemHeight || !state.visibleItemCount || !Array.isArray(state.options) || state.animationTime === undefined) {
    return
  }
  updatePreState(instanceId, domState)
  updateState(instanceId, 'animationIndex', state.activeIndex)
  updateVisibleOptions(state.animationIndex, instanceId);
  updateWrapperStyle(instanceId, ownerInstance);
}

const touchStart = (instanceId) => (event) => {
  const state = getCurrState(instanceId);
  if (state.endTimer) {
    clearInterval(state.endTimer);
    clearTimeout(state.endTimer);
    updateState(instanceId, 'endTimer', null);
  } else {
    updateState(instanceId, 'recentVelocity', 0);
  }
  if(state.tapTimer) {
    clearTimeout(state.tapTimer);
    updateState(instanceId, 'tapTimer', null);
  }
  const { pageY } = event.touches[0];
  startPo.y = pageY;
  updateState(instanceId, 'moving', false);
  updateState(instanceId, 'startOffset', state.animationIndex * state.itemHeight);
  updateState(instanceId, 'preOffsetting', state.animationIndex * state.itemHeight);
  updateState(instanceId, 'preOffsetList', []);
}

const touchMove = (instanceId) => (event, ownerInstance) => {
  const state = getCurrState(instanceId);
  const { pageY } = event.touches[0];
  const offsetY = pageY - startPo.y;
  const offsetting = -state.startOffset + offsetY;
  const newOffsetList = [...state.preOffsetList, offsetting];
  const animationIndex = -offsetting / state.itemHeight;
  const preIndexLast = Math.abs(state.animationIndex % 1);
  const curIndexLast = Math.abs(animationIndex % 1);
  const offsetCompare = offsetting - state.preOffsetting;
  const direction =
    offsetCompare < 0 ? 'down' : offsetCompare > 0 ? 'up' : state.movingDirection;
  updateVisibleOptions(animationIndex, instanceId);
  const isOverOptions = state.loop ? false : animationIndex < 0 || animationIndex > state.options.length - 1;
  const activeIndex = Math.round(animationIndex);
  const isDisabled = wxUtils.isObj(state.options[activeIndex]) && state.options[activeIndex].disabled;
  if (
    ((direction === 'down' && preIndexLast < 0.5 && curIndexLast >= 0.5) ||
      (direction === 'up' && preIndexLast >= 0.5 && curIndexLast < 0.5))
    && !isOverOptions
    && !isDisabled
  ) {
    ownerInstance.callMethod('animationIndexChange', animationIndex);
    ownerInstance.callMethod('vibrateShort');
  }

  if (!state.moving) {
    ownerInstance.callMethod('animationStart');
  }

  updateState(instanceId, 'moving', true);
  updateState(instanceId, 'animationIndex', animationIndex);
  updateState(instanceId, 'preOffsetting', offsetting);
  updateState(instanceId, 'preOffsetList', newOffsetList);
  updateState(instanceId, 'movingDirection', direction);

  updateWrapperStyle(instanceId, ownerInstance);
}

function updateVisibleOptions(currentIndex, instanceId) {
  const state = getCurrState(instanceId);
  let animationIndex = Math.round(
    currentIndex !== undefined ? currentIndex : state.animationIndex
  );
  const vOptionLength = state.visibleItemCount * 4 - 2;
  const rotateAngle = 360 / vOptionLength;
  const newArr = new Array(vOptionLength).fill('');
  const partCount = Math.floor(state.visibleItemCount / 2) + 3;
  const newValueArr = new Array(partCount * 2 + 1).fill('');
  if (state.loop) {
    newValueArr.forEach((item, index) => {
      const valueIndex = (animationIndex - partCount + index) % state.options.length;
      const listIndex = valueIndex < 0 ? state.options.length - 1 + valueIndex : valueIndex;
      newValueArr[index] = listIndex;
    });
  } else {
    if (animationIndex < 0) {
      animationIndex = 0;
    }
    if (animationIndex > state.options.length - 1) {
      animationIndex = state.options.length - 1;
    }
    newValueArr.forEach((item, index) => {
      const valueIndex =
        animationIndex - partCount + index >= 0 ? animationIndex - partCount + index : undefined;
      if (valueIndex === undefined) {
        return;
      }
      newValueArr[index] = valueIndex;
    });
  }
  const rotate = (animationIndex * rotateAngle) % 360;
  const rotateIndex = Math.round(rotate / rotateAngle);

  // 环形结构填充：以rotateIndex为中心，向两边扩展填充newValueArr
  const centerIndex = rotateIndex; // 中心位置
  const halfLength = Math.floor(newValueArr.length / 2); // newValueArr的一半长度

  // 从中心位置开始，向两边填充
  for (let i = 0; i < newValueArr.length; i++) {
    const targetIndex = (centerIndex - halfLength + i + vOptionLength) % vOptionLength; // 确保索引在0-17范围内
    newArr[targetIndex] = newValueArr[i];
  }
  updateState(instanceId, 'optionsVIndexList', newArr);
  return newArr
}

function getWrapperCSSVar(instanceId) {
  const state = getCurrState(instanceId);
  const optionsVIndexList = state.optionsVIndexList;
  return optionsVIndexList.reduce((previousValue, currentValue, currentIndex) => {
    if (currentValue === '' || currentValue === undefined) {
      previousValue[`--picker-item-content_${currentIndex}`] = `""`;
    } else {
      const text = optionText(state.options, currentValue, state.valueKey);
      previousValue[`--picker-item-content_${currentIndex}`] = `"${text === undefined ? '' : text}"`;
    }
    return previousValue;
  }, {});
}

function updateWrapperStyle(instanceId, ownerInstance, style = {}) {
  const state = getCurrState(instanceId);
  var perAngle = 360 / (state.visibleItemCount * 4 - 2)
  var rotate = perAngle * state.animationIndex;
  var cssVar = getWrapperCSSVar(instanceId);
  setStyle(ownerInstance, {
    transition: state.moving ? 'none' : 'transform ' + state.animationTime + 'ms cubic-bezier(0.2, 0.9, 0.25, 1)',
    transform: `rotateX(${rotate}deg)`,
    ...style,
    ...cssVar
  }, '.smart-picker-column__offset');
}

const touchEnd = (instanceId) => (event, ownerInstance) => {
  const state = getCurrState(instanceId);
  if (!state.moving) {
    return;
  }
  const preOffsetList = state.preOffsetList;
  // 计算最后几帧的平均速度，用于惯性滚动
  let recentVelocity = 0;
  /** -1: 向下, 1: 向上, 0: 无滚动 */
  let scrollDirection = 0;

  if (preOffsetList.length >= 2) {
    // 计算速度，优先使用最后几帧的数据
    let recentOffset = 0;
    let recentTime = 0;

    if (preOffsetList.length >= 3) {
      // 有3个或以上数据点，使用最后3个点计算速度
      recentOffset =
        preOffsetList[preOffsetList.length - 1] - preOffsetList[preOffsetList.length - 3];
      recentTime = 2; // 2帧间隔
    } else if (preOffsetList.length === 2) {
      // 只有2个数据点，使用这2个点计算速度
      recentOffset = preOffsetList[1] - preOffsetList[0];
      recentTime = 1; // 1帧间隔
    }

    // 计算速度 (px/ms)
    recentVelocity = state.recentVelocity + Math.abs(recentOffset) / (recentTime * 16);
    updateState(instanceId, 'recentVelocity', recentVelocity);
    // 确定滚动方向
    if (recentOffset > 0) {
      scrollDirection = 1; // 向上滚动
    } else if (recentOffset < 0) {
      scrollDirection = -1; // 向下滚动
    }
  }

  // 惯性滚动参数配置
  const minVelocity = 0.1; // 最小速度阈值，低于此值停止滚动
  const maxInertiaDistance = state.itemHeight * Math.max(Math.floor(state.options.length/4), 10); // 最大惯性滚动距离
  // 计算惯性滚动距离
  let inertiaDistance = 0;
  if (recentVelocity > minVelocity) {
    // 使用物理公式计算惯性距离：distance = velocity^2 / (2 * friction)
    // 这里简化处理，直接使用速度乘以一个系数
    inertiaDistance = recentVelocity * 150; // 200ms的惯性时间

    // 限制最大滚动距离
    if (inertiaDistance > maxInertiaDistance) {
      console.log('first')
      inertiaDistance = maxInertiaDistance;
    }

    // 根据滚动方向确定正负值
    inertiaDistance *= scrollDirection;
  }

  // 计算最终目标位置 和 index
  let targetOffset =
    Math.round((state.preOffsetting + inertiaDistance) / state.itemHeight) *
    state.itemHeight;
  let currTargetActiveIndex = -targetOffset / state.itemHeight;
  currTargetActiveIndex = adjustIndex(currTargetActiveIndex, state.options);
  targetOffset = -currTargetActiveIndex * state.itemHeight;
  const animationOffset = Math.abs(targetOffset - state.preOffsetting);
  const isOverOptions = state.loop ? false : state.animationIndex < 0 || state.animationIndex > state.options.length - 1;
  const totalDistance = targetOffset - state.preOffsetting;
    // 如果动画时间大于150ms，并且滚动距离大于itemHeight，则需要进行动态更新列表
  if (state.animationTime > 200 && animationOffset > state.itemHeight && !isOverOptions) {
    const midTime = 20;
    const countOffsetIndex = Math.abs(Math.round(currTargetActiveIndex - state.animationIndex));
    const maxVibrateShort = Math.floor(state.animationTime / 30);
    
    // 基于时间的减速动画参数
    const totalFrames = Math.floor(state.animationTime / midTime); // 总帧数
    const startOffset = state.preOffsetting;
    let frameCount = 0;
    const startTime = Date.now();
    
    const endTimer = setInterval(() => {
      frameCount++;
      const elapsedTime = Date.now() - startTime;
      const progress = Math.min(elapsedTime / state.animationTime, 1); // 进度 0-1
      
      // 使用缓动函数实现减速效果：easeOutCubic
      // f(t) = 1 - (1-t)^3，开始快，结束慢
      const easedProgress = 1 - Math.pow(1 - progress, 3);
      
      // 计算当前偏移量
      const currentOffset = startOffset + totalDistance * easedProgress;
      
      if (progress >= 1 || frameCount >= totalFrames) {
        // 动画完成，设置为精确的目标位置
        updateVisibleOptions(currTargetActiveIndex, instanceId);
        updateWrapperStyle(instanceId, ownerInstance);
        clearInterval(endTimer);
        updateState(instanceId, 'endTimer', null);
        updateState(instanceId, 'moving', false);
        updateState(instanceId, 'animationIndex', currTargetActiveIndex);
        ownerInstance.callMethod('activeIndexChange', currTargetActiveIndex, true);
        setTimeout(() => {
          ownerInstance.callMethod('animationEnd');
        }, 0);
        return;
      }
      
      const currIndex = -currentOffset / state.itemHeight;
      updateVisibleOptions(currIndex, instanceId);
      updateState(instanceId, 'animationIndex', currIndex);
      ownerInstance.callMethod('animationIndexChange', currIndex);
      updateWrapperStyle(instanceId, ownerInstance);
    }, midTime);
    ownerInstance.callMethod('vibrateShort', Math.min(countOffsetIndex, maxVibrateShort), state.animationTime);
    updateState(instanceId, 'endTimer', endTimer);
  } else {
    updateVisibleOptions(currTargetActiveIndex, instanceId);
    updateState(instanceId, 'animationIndex', currTargetActiveIndex);
    updateWrapperStyle(instanceId, ownerInstance, {
      transition: 'transform ' + 200 + 'ms cubic-bezier(0.2, 0.9, 0.25, 1)'
    });
    setTimeout(() => {
      updateState(instanceId, 'moving', false);
      ownerInstance.callMethod('animationEnd');
      ownerInstance.callMethod('activeIndexChange', currTargetActiveIndex, true);
    }, 150);
  }
}

const tapItem = (instanceId) => (e, ownerInstance) => {
  const state = getCurrState(instanceId);
  const rotateIndex = e.currentTarget.dataset.index;
  const currTargetActiveIndex = state.optionsVIndexList[rotateIndex];
  const option = state.options[currTargetActiveIndex];
  if (option === undefined || option && typeof option === 'object' && option.disabled) return;
  if (state.startTimer) {
    clearTimeout(state.startTimer);
    updateState(instanceId, 'startTimer', null);
  }
  if (currTargetActiveIndex === state.animationIndex) return;
  const offsetCount = Math.abs(currTargetActiveIndex - state.animationIndex);
  if (state.tapTimer) {
    clearTimeout(state.tapTimer);
    updateState(instanceId, 'tapTimer', null);
  }
  updateVisibleOptions(currTargetActiveIndex, instanceId);
  updateState(instanceId, 'animationIndex', currTargetActiveIndex);
  updateWrapperStyle(instanceId, ownerInstance, {
    transition: 'transform ' + 300 + 'ms cubic-bezier(0.2, 0.9, 0.25, 1)'
  });
  ownerInstance.callMethod('vibrateShort', offsetCount, 200);
  const tapTimer = setTimeout(() => {
    ownerInstance.callMethod('activeIndexChange', currTargetActiveIndex);
    updateState(instanceId, 'tapTimer', null);
  }, 200);
  updateState(instanceId, 'tapTimer', tapTimer);
}


module.exports = {
  optionText: optionText,
  rootStyle: rootStyle,
  wrapperStyle: wrapperStyle,
  wrapperInterStyle: wrapperInterStyle,
  wrapperItemStyle: wrapperItemStyle,
  wrapperItemClass: wrapperItemClass,
  wrapperItemTextStyle: wrapperItemTextStyle,
  updateValue: updateValue,
  touchStart: touchStart,
  touchMove: touchMove,
  touchEnd: touchEnd,
  tapItem: tapItem,
};
