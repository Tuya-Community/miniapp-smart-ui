/* eslint-disable */
var style = require('../wxs/style.wxs');
var addUnit = require('../wxs/add-unit.wxs');
var wxUtils = require('../wxs/utils.wxs');

let startPo = { y: 0 }; // 记录当前拖动元素的开始的位置

const setStyle = (ownerInstance, style, selector) => {
  const dom = queryComponent(ownerInstance, selector);
  dom.setStyle(style);
};

const queryComponent = function (ownerInstance, selector) {
  const instance = ownerInstance?.selectComponent(selector);
  return instance;
};

function isObj(x) {
  var type = typeof x;
  return x !== null && (type === 'object' || type === 'function');
}

function optionText(option, valueKey) {
  return isObj(option) && option[valueKey] != null ? option[valueKey] : option;
}

function rootStyle(data) {
  return style({
    height: addUnit(data.itemHeight * data.visibleItemCount),
  });
}

function wrapperStyle(data) {
  var offset =
    data.offset + (data.itemHeight * (data.visibleItemCount - 1)) / 2;
  offset = addUnit(offset);
  if (data.animate) {
    return style({
      'text-indent': data.unit ? '-8rpx' : '0',
      transition: 'transform ' + data.duration + 'ms ease-out',
      'line-height': addUnit(data.itemHeight),
      // transform: 'translate3d(0, ' + offset + ', 0)',
    });
  }
  return style({
    'text-indent': data.unit ? '-8rpx' : '0',
    'line-height': addUnit(data.itemHeight),
    // transform: 'translate3d(0, ' + offset + ', 0)',
  });
}

function wrapperInterStyle(data) {
  var offset = data.renderStart * data.itemHeight;
  offset = addUnit(offset);
  return style({
    'padding-top': offset,
  });
}

function wrapperItemStyle(data) {
  var heightStyleStr = "height: " + data.itemHeight + 'px;'
  var fontStyleStr = style(data.fontStyle);
  var activeStyleStr = style(data.activeStyle);

  // var maxSideShow = Math.floor(data.visibleItemCount / 2) + 1;
  // var offsetIndex = data.animationIndex - data.index;
  // var scale = Math.min(Math.abs(offsetIndex * 0.2), 0.2 * maxSideShow)
  // var rotateX = offsetIndex * 25 > 0 ? Math.min(offsetIndex * 25, 25 * maxSideShow) : Math.max(offsetIndex * 25, -25 * maxSideShow)
  // var translateYIndex = offsetIndex > 0 ? Math.min(offsetIndex, maxSideShow) : Math.max(offsetIndex, -maxSideShow)
  // const transStyle = style({
  //   transform: `rotateX(${rotateX}deg) scale(${1 - scale}) translateY(${translateYIndex * Math.abs(translateYIndex) * Math.abs(translateYIndex) * data.itemHeight * 0.1}px) translateZ(0)`,
  // });
  // return transStyle + ';' + heightStyleStr + (fontStyleStr ? fontStyleStr + ';' : fontStyleStr) + activeStyleStr
  return heightStyleStr + (fontStyleStr ? fontStyleStr + ';' : fontStyleStr) + activeStyleStr
}

function wrapperItemClass(data) {
  var staticClass = 'smart-ellipsis';
  var activeClass = 'active-class';
  var isActive = Math.abs(data.renderStart + data.index - data.animationIndex) < 0.5;
  return staticClass + ' ' + wxUtils.bem('picker-column__item', { disabled: data.option && data.option.disabled, selected: isActive }) + ' ' + (isActive ? activeClass : '');
}

var state = {}

var preStateStr = ''

function updateState(key, value) {
  if (!key) return;
  preStateStr = JSON.stringify(state)
  state[key] = value
}

function getCurrState() {
  return state
}

function getPreState() {
  return preStateStr
}

const updateValue = (key) => (newOptions, oldOptions, ownerInstance) => {
  updateState(key, newOptions)
  updateOffset(ownerInstance)
}

function updateOffset(ownerInstance) {
  const state = getCurrState();
  if(getPreState() === JSON.stringify(state) || !state.itemHeight || !state.visibleItemCount || !Array.isArray(state.options) || state.animationTime === undefined) {
    return
  }
  const sideCount = Math.floor(state.visibleItemCount / 2)
  const optionLength = state.options.length;
  updateState('sideCount', sideCount);
  const currActiveIndex = state.activeIndex < 0 ? 0 : state.activeIndex >= optionLength ? optionLength - 1 : state.activeIndex;
  const currList = getCurrList(state.options, currActiveIndex, state.loop, sideCount)
  const textVarStyle = {}
  currList.forEach((option, index) => {
    textVarStyle['--picker-item-content_' + index] = "'" + optionText(option, state.valueKey) + "'"
  })
  if (state.loop) { 
    const offsetCount = 9 - sideCount
    const offset = -state.itemHeight * offsetCount;
    const activeOffsetIndexMultiplier = Math.round(currActiveIndex / optionLength);
    updateState('offsetActiveIndex', activeOffsetIndexMultiplier * optionLength + currActiveIndex);
    updateState('offset', offset)
    setStyle(ownerInstance, {
      transform: 'translateY(' + addUnit(offset) + ')',
      ...textVarStyle,
    }, '.smart-picker-column__offset');
  } else {

    const offset = (state.offset || 0) + state.itemHeight * (sideCount - currActiveIndex);
    updateState('offset', offset)
    updateState('offsetActiveIndex', currActiveIndex);
    setStyle(ownerInstance, {
      transform: 'translateY(' + addUnit(offset) + ')',
      ...textVarStyle,
    }, '.smart-picker-column__offset');

    setTimeout(() => { 
      updateItemStyle(ownerInstance, currActiveIndex);
    }, 10)
  }
}

const updateItemStyle = (ownerInstance, currActiveIndex) => {
  const state = getCurrState();
  state.options.slice(0, 20).map((item, index) => {
    const maxSideShow = state.sideCount + 2;
    const offsetIndex = currActiveIndex - index;
    if(Math.abs(offsetIndex) > maxSideShow) return;
    const finOffsetIndex = offsetIndex > 0 ? Math.min(offsetIndex, maxSideShow) : Math.max(offsetIndex, -maxSideShow);
    const scale = 1 - Math.abs(finOffsetIndex * 0.15);
    const rotateX = Math.abs(finOffsetIndex * 10);
    const direction = offsetIndex > 0 ? 1 : -1;
    const translateYIndex = Math.abs(finOffsetIndex);
    const translateYOffset = translateYIndex * translateYIndex * direction * state.itemHeight * 0.1
    const className = `.smart-picker-column__item_${index}`;
    setStyle(ownerInstance, {
      transform: `rotateX(${rotateX}deg) scale(${scale}) translateY(${translateYOffset}px) translateZ(0)`,
      transition: 'none',
    }, className);
  })
}

const getCurrList = (options, activeIndex, loop, sideCount) => {
  if (loop) {
    return [...options.slice(-9), ...options.slice(0, 10)]
  } else {
    const startIndex = activeIndex - sideCount < 0 ? 0 : activeIndex - sideCount;
    const endIndex = startIndex + 20 > options.length ? options.length : startIndex + 20;
    return options.slice(startIndex, endIndex)
  }
}

const touchStart = function (e, ownerInstance) { 
  const state = getCurrState();
  if(state.timer) {
    clearInterval(state.timer);
    updateState('timer', null);
    updateState('offset', state.offsetting);
  }
  const { pageY } = e.touches[0];
  startPo.y = pageY;
  updateState('offsetList', []);
  updateState('moving', true);
  updateState('offsetting', state.offset);
}

const touchMove = function (e, ownerInstance) { 
  const state = getCurrState();
  if(!state.moving) return;
  const { pageY } = e.touches[0];
  let offsetY = pageY - startPo.y;
  const offset = state.offset + offsetY;
  const newOffsetList = [...state.offsetList, offset];
  const currActiveIndex = -offset / state.itemHeight + state.sideCount;
  updateState('offsetActiveIndex', currActiveIndex);
  updateState('offsetting', offset);
  updateState('offsetList', newOffsetList);
  setStyle(ownerInstance, {
    transform: 'translateY(' + addUnit(offset) + ')',
    transition: 'none',
  }, '.smart-picker-column__offset');
  updateItemStyle(ownerInstance, currActiveIndex);
  ownerInstance.callMethod('activeIndexChange', currActiveIndex);
}

const touchEnd = function (e, ownerInstance) { 
  const state = getCurrState();
  if(!state.moving) return;
  const preOffsetList = state.offsetList;

  const maxUpOptionsDistance = state.loop ? state.itemHeight * 500 : state.sideCount * state.itemHeight;
  const maxDownOptionsDistance = state.loop ? -state.itemHeight * 500 : -Math.max((state.options.length - state.sideCount - 1) * state.itemHeight, 0);
  // 计算最后几帧的平均速度，用于惯性滚动
  let recentVelocity = 0;
  let scrollDirection = 0; // 1: 向下, -1: 向上, 0: 无滚动
  
  if (preOffsetList.length >= 2) {
    // 计算速度，优先使用最后几帧的数据
    let recentOffset = 0;
    let recentTime = 0;
    
    if (preOffsetList.length >= 3) {
      // 有3个或以上数据点，使用最后3个点计算速度
      recentOffset = preOffsetList[preOffsetList.length - 1] - preOffsetList[preOffsetList.length - 3];
      recentTime = 2; // 2帧间隔
    } else if (preOffsetList.length === 2) {
      // 只有2个数据点，使用这2个点计算速度
      recentOffset = preOffsetList[1] - preOffsetList[0];
      recentTime = 1; // 1帧间隔
    }
    
    // 计算速度 (px/ms)
    recentVelocity = Math.abs(recentOffset) / (recentTime * 16);
    
    // 确定滚动方向
    if (recentOffset > 0) {
      scrollDirection = 1; // 向下滚动
    } else if (recentOffset < 0) {
      scrollDirection = -1; // 向上滚动
    }
  }
  
  // 惯性滚动参数配置
  const minVelocity = 0.1; // 最小速度阈值，低于此值停止滚动
  const maxInertiaDistance = state.itemHeight * 8; // 最大惯性滚动距离
  
  // 计算惯性滚动距离
  let inertiaDistance = 0;
  if (recentVelocity > minVelocity) {
    // 使用物理公式计算惯性距离：distance = velocity^2 / (2 * friction)
    // 这里简化处理，直接使用速度乘以一个系数
    inertiaDistance = recentVelocity * 200; // 200ms的惯性时间
    
    // 限制最大滚动距离
    if (inertiaDistance > maxInertiaDistance) {
      inertiaDistance = maxInertiaDistance;
    }
        
    // 根据滚动方向确定正负值
    inertiaDistance = inertiaDistance * scrollDirection;
  }

  // 计算最终目标位置
  let targetOffset = Math.floor((state.offsetting + inertiaDistance) / state.itemHeight) * state.itemHeight;
  console.log(targetOffset, maxDownOptionsDistance, maxUpOptionsDistance, '---targetOffset')
  if (targetOffset < 0 && targetOffset < maxDownOptionsDistance) { 
    targetOffset = maxDownOptionsDistance;
  } else if (targetOffset > 0 && targetOffset > maxUpOptionsDistance) { 
    targetOffset = maxUpOptionsDistance;
  }

  const isNeedTransition = Math.abs(targetOffset - state.offsetting) > 1;
  const currTargetActiveIndex = -targetOffset / state.itemHeight + state.sideCount;
  console.log(currTargetActiveIndex, '---end')
  const time = isNeedTransition ? state.animationTime : 0;
  console.log(time, '--time')
  if (time > 150) {
    const midTime = 16;
    const count = Math.floor((time - 150) / midTime);
    const midOffset = (targetOffset - state.offsetting)/ count;
    let startCount = 0
    console.log(currTargetActiveIndex, count, '--start animate')
    const timer = setInterval(() => {
      startCount++;
      const currOffset = state.offsetting + midOffset;
      const currIndex = -currOffset / state.itemHeight + state.sideCount;
      console.log(currIndex, '--currIndex')
      if (startCount >= count) {
        // 动画结束，设置最终状态
        updateState('offsetActiveIndex', currTargetActiveIndex);
        clearInterval(timer);
        updateItemStyle(ownerInstance, currTargetActiveIndex);
        updateState('offsetting', targetOffset);
        updateState('offset', targetOffset);
        updateState('moving', false);
        ownerInstance.callMethod('activeIndexChange', currTargetActiveIndex);
        return 
      };
      updateState('offsetActiveIndex', currIndex);
      updateState('offsetting', currOffset);
      updateItemStyle(ownerInstance, currIndex);
    }, midTime);
    updateState('timer', timer);
  } else {
    updateState('offsetActiveIndex', currTargetActiveIndex);
    updateState('offsetting', targetOffset);
    updateState('offset', targetOffset);
    updateState('moving', false);
    updateItemStyle(ownerInstance, currTargetActiveIndex);
    ownerInstance.callMethod('activeIndexChange', currTargetActiveIndex);
  }
  setStyle(ownerInstance, {
    transform: 'translateY(' + addUnit(Math.round(targetOffset)) + ')',
    transition: 'transform ' + (time ? time + 100 : time) + 'ms',
  }, '.smart-picker-column__offset');
}


module.exports = {
  optionText: optionText,
  rootStyle: rootStyle,
  wrapperStyle: wrapperStyle,
  wrapperInterStyle: wrapperInterStyle,
  wrapperItemStyle: wrapperItemStyle,
  wrapperItemClass: wrapperItemClass,
  updateValue: updateValue,
  touchStart: touchStart,
  touchMove: touchMove,
  touchEnd: touchEnd,
};
