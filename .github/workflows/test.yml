name: Test Publish Manual

on:
  push:
    branches:
      - test/ci2
  workflow_dispatch:

jobs:
  test_publish:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.PROTECT_WRITE_TOKEN }}

    - name: Get Version from package.json
      id: package_version
      run: |
        VERSION=$(node -p "require('./package.json').version")
        echo "VERSION=${VERSION}" >> $GITHUB_OUTPUT
        echo "ğŸ“¦ Current version in package.json: ${VERSION}"

    - name: Call Publish Manual Workflow
      id: trigger_workflow
      uses: benc-uk/workflow-dispatch@v1
      with:
        workflow: publish-manual.yml
        repo: Tuya-Community/ray-smart-ui
        token: ${{ secrets.PROTECT_WRITE_TOKEN }}
        ref: test/ci
        inputs: '{"version":"${{ steps.package_version.outputs.VERSION }}"}'

    - name: Wait for Workflow Completion
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.PROTECT_WRITE_TOKEN }}
        script: |
          const targetOwner = 'Tuya-Community';
          const targetRepo = 'ray-smart-ui';
          const workflowName = 'publish-manual.yml';
          const maxWaitTime = 30 * 60 * 1000; // 30 åˆ†é’Ÿè¶…æ—¶
          const pollInterval = 10 * 1000; // æ¯ 10 ç§’æ£€æŸ¥ä¸€æ¬¡
          const startTime = Date.now();
          
          console.log('â³ Waiting for workflow to complete...');
          
          // ä½¿ç”¨å·¥ä½œæµæ–‡ä»¶åä½œä¸º IDï¼ˆGitHub API æ”¯æŒæ–‡ä»¶åæˆ–æ•°å­— IDï¼‰
          const workflowId = workflowName;
          console.log(`ğŸ“‹ Using workflow: ${workflowId}`);
          
          // ç­‰å¾…ä¸€å°æ®µæ—¶é—´ï¼Œè®©å·¥ä½œæµå¼€å§‹è¿è¡Œ
          await new Promise(resolve => setTimeout(resolve, 5000));
          
          // è½®è¯¢æ£€æŸ¥å·¥ä½œæµçŠ¶æ€
          let runId = null;
          let attempts = 0;
          const maxAttempts = 10;
          
          // é¦–å…ˆæ‰¾åˆ°æœ€æ–°è§¦å‘çš„å·¥ä½œæµè¿è¡Œ
          while (!runId && attempts < maxAttempts) {
            try {
              const runs = await github.rest.actions.listWorkflowRuns({
                owner: targetOwner,
                repo: targetRepo,
                workflow_id: workflowId,
                per_page: 1,
              });
              
              if (runs.data.workflow_runs.length > 0) {
                const latestRun = runs.data.workflow_runs[0];
                // æ£€æŸ¥æ˜¯å¦æ˜¯æœ€è¿‘ 2 åˆ†é’Ÿå†…è§¦å‘çš„ï¼ˆé¿å…åŒ¹é…åˆ°æ—§è¿è¡Œï¼‰
                const runTime = new Date(latestRun.created_at).getTime();
                const timeDiff = Date.now() - runTime;
                
                if (timeDiff < 2 * 60 * 1000) {
                  runId = latestRun.id;
                  console.log(`âœ… Found workflow run ID: ${runId}`);
                  console.log(`   Status: ${latestRun.status}, Conclusion: ${latestRun.conclusion || 'pending'}`);
                }
              }
            } catch (error) {
              console.log(`âš ï¸  Error finding workflow run (attempt ${attempts + 1}): ${error.message}`);
            }
            
            if (!runId) {
              attempts++;
              await new Promise(resolve => setTimeout(resolve, 3000));
            }
          }
          
          if (!runId) {
            throw new Error('Could not find the triggered workflow run');
          }
          
          // è½®è¯¢ç­‰å¾…å·¥ä½œæµå®Œæˆ
          while (true) {
            const elapsed = Date.now() - startTime;
            if (elapsed > maxWaitTime) {
              throw new Error(`Workflow did not complete within ${maxWaitTime / 1000 / 60} minutes`);
            }
            
            try {
              const run = await github.rest.actions.getWorkflowRun({
                owner: targetOwner,
                repo: targetRepo,
                run_id: runId,
              });
              
              const status = run.data.status;
              const conclusion = run.data.conclusion;
              
              console.log(`ğŸ“Š Workflow status: ${status}, Conclusion: ${conclusion || 'pending'}`);
              
              // æ£€æŸ¥æ˜¯å¦å®Œæˆ
              if (status === 'completed') {
                const runUrl = run.data.html_url;
                console.log(`âœ… Workflow completed!`);
                console.log(`ğŸ”— Run URL: ${runUrl}`);
                
                if (conclusion === 'success') {
                  console.log('âœ… Workflow completed successfully');
                  return;
                } else {
                  throw new Error(`Workflow completed with conclusion: ${conclusion}. Check ${runUrl} for details.`);
                }
              }
              
              // å¦‚æœè¿˜åœ¨è¿è¡Œï¼Œç­‰å¾…åç»§ç»­æ£€æŸ¥
              await new Promise(resolve => setTimeout(resolve, pollInterval));
            } catch (error) {
              if (error.message.includes('completed')) {
                throw error;
              }
              console.log(`âš ï¸  Error checking workflow status: ${error.message}`);
              await new Promise(resolve => setTimeout(resolve, pollInterval));
            }
          }

